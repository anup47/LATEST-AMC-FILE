// ─────────────────────────────────────────
// LIVE STOCK PRICES — Yahoo Finance (15min delayed)
// Uses 15m intraday data (range=5d)
// ─────────────────────────────────────────

async function fetchStockPrice(symbol, basePrice, sector) {
  const ticker = YF_SYMBOL[symbol];
  if (!ticker) return fallbackPrice(symbol, basePrice, sector);

  try {
    const url = `https://query1.finance.yahoo.com/v8/finance/chart/${ticker}?interval=15m&range=5d`;
    const proxy = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;

    const res = await fetch(proxy, { signal: AbortSignal.timeout(7000) });
    if (!res.ok) throw new Error("Yahoo fetch failed");

    const data = await res.json();
    const result = data?.chart?.result?.[0];
    if (!result) throw new Error("No chart data");

    const closes = result.indicators.quote[0].close.filter(v => v != null);
    if (closes.length < 5) throw new Error("Insufficient price data");

    const curr = closes[closes.length - 1];
    const prev1d = closes[closes.length - 2] || curr;

    // Weekly/monthly from 15m data (approximation)
    const prev1w = closes[Math.max(0, closes.length - 130)];
    const prev1m = closes[Math.max(0, closes.length - 520)];
    const prev3m = closes[Math.max(0, closes.length - 1500)];

    return {
      curr,
      prev: prev1d,
      change: ((curr - prev1d) / prev1d) * 100,
      r1w: ((curr - prev1w) / prev1w) * 100,
      r1m: ((curr - prev1m) / prev1m) * 100,
      r3m: ((curr - prev3m) / prev3m) * 100,
      live: true
    };

  } catch (err) {
    console.warn("Live price failed for:", symbol, err.message);
    return fallbackPrice(symbol, basePrice, sector);
  }
}

async function fetchAllStockPrices(onProgress) {
  const uniqueStocks = new Map();

  for (let amc in holdings) {
    for (let h of holdings[amc]) {
      if (!uniqueStocks.has(h.stock)) {
        uniqueStocks.set(h.stock, { basePrice: h.basePrice, sector: h.sector });
      }
    }
  }

  let done = 0;
  const entries = [...uniqueStocks.entries()];

  for (let [sym, info] of entries) {
    stockPrices[sym] = await fetchStockPrice(sym, info.basePrice, info.sector);
    done++;

    if (onProgress) {
      onProgress(sym, done, entries.length, stockPrices[sym].live);
    }

    await new Promise(r => setTimeout(r, 150)); // avoid rate-limit
  }
}
